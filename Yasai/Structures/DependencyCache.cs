using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace Yasai.Structures
{
    /// <summary>
    /// Injects dependencies
    /// </summary>
    public class DependencyCache 
    {
        private Dictionary<string, ITraceable> cache;

        public DependencyCache() => cache = new Dictionary<string, ITraceable>();

        public void SetDict(Dictionary<string, ITraceable> c) => cache = c;

        private string getKey<T>(string c="default") => $"{typeof(T)}_{c}";

        /// <summary>
        /// Store something in the cache with an autogenerated context.
        /// The context being of the form "[Type name]_default"
        /// </summary>
        /// <param name="item"></param>
        /// <typeparam name="T"></typeparam>
        public void Store<T>(Traceable<T> item) 
            => Store(item, getKey<T>());

        /// <summary>
        /// Store something in the cache with a context
        /// </summary>
        /// <param name="item"></param>
        /// <param name="context"></param>
        /// <param name="rawContext"></param>
        /// <typeparam name="T"></typeparam>
        public void Store<T>(Traceable<T> item, string context, bool rawContext = false) 
        {
            var k = rawContext ? context : getKey<T>(context);
            item.Change += delegate(T value)
            {
                var l = new Traceable<T>(value);
                Store(l);
            };
            cache[k] = item;
        }

        /// <summary>
        /// Retrieve a dependency from the cache
        /// </summary>
        /// <param name="key"></param>
        /// <typeparam name="T"></typeparam>
        /// <returns></returns>
        public Traceable<T> Retrieve<T>(string key = null)
        {
            var k = getKey<T>(key ?? getKey<T>());
            if (!cache.ContainsKey(k))
                throw new KeyNotFoundException($"no such {key} of type {typeof(T)} in the internal cache");

            return (Traceable<T>)cache[k];
        }
    }
}